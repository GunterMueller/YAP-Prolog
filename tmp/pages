*******************************

/** @page SWIhYProlog_Emulation SWI-Prolog Emulation

This library provides a number of SWI-Prolog builtins that are not by
default in YAP. This support is loaded with the
`expects_dialect(swi)` command.


*/


*******************************

/** @page SWIhYProlog_Global_Variables SWI Global variables


SWI-Prolog global variables are associations between names (atoms) and
terms.  They differ in various ways from storing information using
assert/1 or recorda/3.

+ The value lives on the Prolog (global) stack.  This implies 
that lookup time is independent from the size of the term.
This is particulary interesting for large data structures
such as parsed XML documents or the CHR global constraint
store.

They support both global assignment using nb_setval/2 and
backtrackable assignment using b_setval/2.

+ Only one value (which can be an arbitrary complex Prolog
term) can be associated to a variable at a time.

+ Their value cannot be shared among threads.  Each thread
has its own namespace and values for global variables.

+ Currently global variables are scoped globally.  We may
consider module scoping in future versions.


Both b_setval/2 and nb_setval/2 implicitly create a variable if the
referenced name does not already refer to a variable.

Global variables may be initialised from directives to make them
available during the program lifetime, but some considerations are
necessary for saved-states and threads. Saved-states to not store global
variables, which implies they have to be declared with initialization/1
to recreate them after loading the saved state.  Each thread has
its own set of global variables, starting with an empty set.  Using
`thread_inititialization/1` to define a global variable it will be
defined, restored after reloading a saved state and created in all
threads that are created <em>after</em> the registration.

 
*/


*******************************

/** @page Extensions Extensions to Prolog

YAP includes a number of extensions over the original Prolog
language. Next, we discuss support to the most important ones.


 */


*******************************

/** @page Efficiency Efficiency Considerations

We next discuss several issues on trying to make Prolog programs run
fast in YAP. We assume two different programming styles:

+ Execution of <em>deterministic</em> programs often
boils down to a recursive loop of the form:

~~~~~
loop(Env) :-
        do_something(Env,NewEnv),
        loop(NewEnv).
~~~~~




 */


*******************************

/** @page ChYInterface C Language interface to YAP

YAP provides the user with three facilities for writing
predicates in a language other than Prolog. Under Unix systems,
most language implementations were linkable to `C`, and the first interface exported  the YAP machinery to the C language. YAP also implements most of the SWI-Prolog foreign language interface.
This gives portability with a number of SWI-Prolog packages. Last, a new C++ based interface is 
being designed to work with the swig (@url(www.swig.org}) interface compiler.

+ The @ref c-interface  YAP C-interface exports the YAP engine.
+ The @ref swi-c-interface emulates Jan Wielemaker's SWI foreign language interface.
+ The @ref  yap-cplus-interface is desiged to interface with Object-Oriented systems.




 */


