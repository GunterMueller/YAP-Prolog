*******************************

/** 

@defgroup YAPControl Control Predicates
@ingroup YAPBuiltins
@{

*/


*******************************

/** @pred  + _P_ is nondet

The same as `call( _P_)`. This feature has been kept to provide
compatibility with C-Prolog. When compiling a goal, YAP
generates a `call( _X_)` whenever a variable  _X_ is found as
a goal.

~~~~~{.prolog}
 a(X) :- X.
~~~~~
is converted to:

~~~~~{.prolog}
 a(X) :- call(X).
~~~~~

 
*/


*******************************

/** @pred  _CurrentModule_:term_expansion( _T_,- _X_),  user:term_expansion( _T_,- _X_) 


This user-defined predicate is called by `expand_term/3` to
preprocess all terms read when consulting a file. If it succeeds:

+ 
If  _X_ is of the form `:- G` or `?- G`, it is processed as
a directive.
+ 
If  _X_ is of the form `$source_location`( _File_, _Line_): _Clause_` it is processed as if from `File` and line `Line`.

+ 
If  _X_ is a list, all terms of the list are asserted or processed
as directives.
+ The term  _X_ is asserted instead of  _T_.


 
*/


*******************************

/** @pred  _CurrentModule_:goal_expansion(+ _G_,+ _M_,- _NG_), user:goal_expansion(+ _G_,+ _M_,- _NG_) 


YAP now supports goal_expansion/3. This is an user-defined
procedure that is called after term expansion when compiling or
asserting goals for each sub-goal in a clause. The first argument is
bound to the goal and the second to the module under which the goal
 _G_ will execute. If goal_expansion/3 succeeds the new
sub-goal  _NG_ will replace  _G_ and will be processed in the same
way. If goal_expansion/3 fails the system will use the default
rules.

 
*/


*******************************

/** @pred  `C`( _S1_, _T_, _S2_) 


This predicate is used by the grammar rules compiler and is defined as
`C`([H|T],H,T)`.




 */


*******************************

/** @pred initialization

Execute the goals defined by initialization/1. Only the first answer is
considered.

 
*/


*******************************

/** @pred [nondet]aggregate(+ _Template_, + _Discriminator_, : _Goal_, - _Result_)

Aggregate bindings in  _Goal_ according to  _Template_. The
aggregate/3 version performs setof/3 on  _Goal_.
 
*/


*******************************

/** @pred _X_ #= is det
all elements of  _X_  must take the same value
 
*/


*******************************

/** @pred _X_ #\=  is det
not all elements of  _X_  take the same value
 
*/


*******************************

/** @pred _X_ #>  is det
elements of  _X_  must be increasing
 
*/


*******************************

/** @pred _X_ #>=  is det
elements of  _X_  must be increasinga or equal
 
*/


*******************************

/** @pred _X_ #=<  is det
elements of  _X_  must be decreasing
 
*/


*******************************

/** @pred _X_ #<  is det
elements of  _X_  must be decreasing or equal

 
*/


*******************************

/** @pred :- fragile  _P_,....,_Pn_ is directive


Declares the predicate  _P_=<tt>[module:]name/arity</tt> as a fragile
predicate, module is optional, default is the current
typein_module. Whenever such a fragile predicate is used in a query
it will be called through call_cleanup/1.

~~~~~{.prolog}
:- fragile foo/1,bar:baz/2.
~~~~~

 
*/


*******************************

/** @pred undgraph_vertices(+ _Graph_, - _Vertices_) 


Unify  _Vertices_ with all vertices appearing in graph
 _Graph_.

 
*/


*******************************

/** @pred undgraph_edge(+ _N1_, + _N2_, + _Graph_) 


Edge  _N1_- _N2_ is an edge in undirected graph  _Graph_.

 
*/


*******************************

/** @pred undgraph_complement(+ _Graph_, - _NewGraph_) 


Unify  _NewGraph_ with the graph complementary to  _Graph_.

 
*/


*******************************

/** @pred dgraph_to_undgraph( + _DGraph_, - _UndGraph_) 


Unify  _UndGraph_ with the undirected graph obtained from the
directed graph  _DGraph_.




 */


*******************************

/** @pred _Module_:get_atts( _-Var_, _?ListOfAttributes_) 


Unify the list  _?ListOfAttributes_ with the attributes for the unbound
variable  _Var_. Each member of the list must be a bound term of the
form `+( _Attribute_)`, `-( _Attribute_)` (the <tt>kbd</tt>
prefix may be dropped). The meaning of <tt>+</tt> and <tt>-</tt> is:
+ +( _Attribute_)
Unifies  _Attribute_ with a corresponding attribute associated with
 _Var_, fails otherwise.

+ -( _Attribute_)
Succeeds if a corresponding attribute is not associated with
 _Var_. The arguments of  _Attribute_ are ignored.

 
*/


*******************************

/** @pred _Module_:put_atts( _-Var_, _?ListOfAttributes_) 


Associate with or remove attributes from a variable  _Var_. The
attributes are given in  _?ListOfAttributes_, and the action depends
on how they are prefixed:
+ +( _Attribute_)
Associate  _Var_ with  _Attribute_. A previous value for the
attribute is simply replace (like with `set_mutable/2`).

+ -( _Attribute_)
Remove the attribute with the same name. If no such attribute existed,
simply succeed.



 */


*******************************

/** @pred _Module_:verify_attributes( _-Var_,  _+Value_,  _-Goals_) 



The predicate is called when trying to unify the attributed variable
 _Var_ with the Prolog term  _Value_. Note that  _Value_ may be
itself an attributed variable, or may contain attributed variables.  The
goal <tt>verify_attributes/3</tt> is actually called before  _Var_ is
unified with  _Value_.

It is up to the user to define which actions may be performed by
<tt>verify_attributes/3</tt> but the procedure is expected to return in
 _Goals_ a list of goals to be called <em>after</em>  _Var_ is
unified with  _Value_. If <tt>verify_attributes/3</tt> fails, the
unification will fail.

Notice that the <tt>verify_attributes/3</tt> may be called even if  _Var_<
has no attributes in module <tt>Module</tt>. In this case the routine should
simply succeed with  _Goals_ unified with the empty list.

 
*/


*******************************

/** @pred _Module_:attribute_goal( _-Var_,  _-Goal_)
User-defined procedure, called to convert the attributes in  _Var_ to
a  _Goal_. Should fail when no interpretation is available.




 */


*******************************

/** @pred _Module_:project_attributes( _+QueryVars_,  _+AttrVars_) 


Given a list of variables  _QueryVars_ and list of attributed
variables  _AttrVars_, project all attributes in  _AttrVars_ to
 _QueryVars_. Although projection is constraint system dependent,
typically this will involve expressing all constraints in terms of
 _QueryVars_ and considering all remaining variables as existentially
quantified.


Projection interacts with attribute_goal/2 at the Prolog top
level. When the query succeeds, the system first calls
project_attributes/2. The system then calls
attribute_goal/2 to get a user-level representation of the
constraints. Typically, attribute_goal/2 will convert from the
original constraints into a set of new constraints on the projection,
and these constraints are the ones that will have an
attribute_goal/2 handler.


 */


*******************************

/** @pred {+ _Constraints_} is det
Adds the constraints given by  _Constraints_ to the constraint store.

 
*/


